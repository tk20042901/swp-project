package com.swp.project.service.user;


import java.security.Principal;
import java.security.SecureRandom;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.swp.project.dto.ChangePasswordDto;
import com.swp.project.dto.DeliveryInfoDto;
import com.swp.project.dto.RegisterDto;
import com.swp.project.entity.PendingRegister;
import com.swp.project.entity.order.Order;
import com.swp.project.entity.product.Product;
import com.swp.project.entity.product.ProductUnit;
import com.swp.project.entity.shopping_cart.ShoppingCartItem;
import com.swp.project.entity.shopping_cart.ShoppingCartItemId;
import com.swp.project.entity.user.Customer;
import com.swp.project.repository.PendingRegisterRepository;
import com.swp.project.repository.order.OrderRepository;
import com.swp.project.repository.product.ProductRepository;
import com.swp.project.repository.shopping_cart.ShoppingCartItemRepository;
import com.swp.project.repository.user.CustomerRepository;
import com.swp.project.repository.user.UserRepository;
import com.swp.project.service.AddressService;
import com.swp.project.service.EmailService;
import com.swp.project.service.product.ProductService;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class CustomerService {

    private final CustomerRepository customerRepository;
    private final UserRepository userRepository;
    private final ProductRepository productRepository;
    private final PasswordEncoder passwordEncoder;
    private final PendingRegisterRepository pendingRegisterRepository;
    private final EmailService emailService;
    private final AddressService addressService;
    private final SecureRandom secureRandom = new SecureRandom();
    private final ShoppingCartItemRepository shoppingCartItemRepository;
    private final OrderRepository orderRepository;
    private final ProductService productService;

    public Customer getCustomerByEmail(String email) {
        return customerRepository.getByEmail(email);
    }

    @Transactional
    public void register(RegisterDto dto) {
        if (!dto.getConfirmPassword().equals(dto.getPassword())) {
            throw new RuntimeException("Mật khẩu và xác nhận mật khẩu không khớp");
        }
        if (userRepository.existsByEmail(dto.getEmail())) {
            throw new RuntimeException("Email " + dto.getEmail() + " đã được sử dụng");
        }
        PendingRegister existedPendingRegister = pendingRegisterRepository.findByEmail(dto.getEmail());
        if (existedPendingRegister != null) {
            pendingRegisterRepository.delete(existedPendingRegister);
        }
        String autoGeneratedOtp = String.valueOf(ThreadLocalRandom.current().nextInt(100000,1000000));
        PendingRegister pendingRegister = PendingRegister.builder()
                .email(dto.getEmail())
                .passwordHash(passwordEncoder.encode(dto.getPassword()))
                .autoGeneratedOtp(autoGeneratedOtp)
                .otpExpiryTime(Instant.now().plusSeconds(300)) // 5 minutes expiry
                .build();

        try {
            emailService.sendSimpleEmail(dto.getEmail(),
                    "Xác minh email của bạn",
                    "OTP xác thực cho email của bạn:\n"
                            + autoGeneratedOtp
                            + "\n\nOTP này sẽ hết hạn sau 5 phút. Nếu bạn không yêu cầu OTP này, vui lòng bỏ qua email này.");
        } catch (Exception e) {
            throw new RuntimeException("Gửi email thất bại. Vui lòng thử lại sau.");
        }

        pendingRegisterRepository.save(pendingRegister);
    }

    @Transactional
    public void verifyOtp(String email, String inputOtp) {
        PendingRegister pendingRegister = pendingRegisterRepository.findByEmail(email);
        if (!pendingRegister.getAutoGeneratedOtp().equals(inputOtp)
                || pendingRegister.getOtpExpiryTime().isBefore(Instant.now())) {
            throw new RuntimeException("OTP không hợp lệ hoặc đã hết hạn");
        }
        Customer customer = Customer.builder()
                .email(pendingRegister.getEmail())
                .password(pendingRegister.getPasswordHash())
                .build();
        customerRepository.save(customer);
        pendingRegisterRepository.delete(pendingRegister);
    }

    @Scheduled(fixedRate = 7200000) //Cleanup PendingRegister every 2 hours
    @Transactional
    public void cleanupExpiredPendingRegistrations() {
        pendingRegisterRepository.deleteByOtpExpiryTimeBefore(Instant.now());
    }

    @Transactional
    public void changePassword(String email, ChangePasswordDto dto) {

        Customer customer = customerRepository.getByEmail(email);

        if (!dto.getNewPassword().equals(dto.getConfirmNewPassword())) {
            throw new RuntimeException("Mật khẩu mới và xác nhận mật khẩu mới không khớp");
        }

        if (!passwordEncoder.matches(dto.getOldPassword(), customer.getPassword())) {
            throw new RuntimeException("Mật khẩu cũ không đúng");
        }

        if(dto.getOldPassword().equals(dto.getNewPassword())) {
            throw new RuntimeException("Mật khẩu mới không được trùng với mật khẩu cũ");
        }

        customer.setPassword(passwordEncoder.encode(dto.getNewPassword()));
        customerRepository.save(customer);
    }

    @Transactional
    public void forgotPassword(String email) {
        if(email == null || email.isBlank()) {
            throw new RuntimeException("Email không được để trống");
        }

        if(!Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$").matcher(email).matches()) {
            throw new RuntimeException("Email không hợp lệ");
        }

        Customer customer = customerRepository.getByEmail(email);

        if (customer == null) throw new RuntimeException("Người dùng với email " + email + " không tồn tại");

        if (customer.getPassword() == null) {
            throw new RuntimeException("Tài khoản này được đăng ký bằng Google. Vui lòng sử dụng Google để đăng nhập.");
        }

        String newPassword = generateSecureRandomPassword();
        customer.setPassword(passwordEncoder.encode(newPassword));
        customerRepository.save(customer);

        emailService.sendSimpleEmail(email,
                "Khôi phục mật khẩu",
                "Mật khẩu vừa được đặt lại. Mật khẩu tạm thời của bạn là:\n"
                        + newPassword
                        + "\n\nVui lòng đăng nhập và thay đổi mật khẩu của bạn.");
    }

    private String generateSecureRandomPassword() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
        StringBuilder password = new StringBuilder();
        for (int i = 0; i < 12; i++) {
            password.append(chars.charAt(secureRandom.nextInt(chars.length())));
        }
        return password.toString();
    }

    @Transactional
    public Customer registerWithGoogle(String email) {
        Customer customer = Customer.builder()
                .email(email)
                .build();
        customerRepository.save(customer);
        return customer;
    }

    public boolean isGoogleRegistered(String email) {
        Customer customer = customerRepository.getByEmail(email);
        return customer.getPassword() == null;
    }

    @Transactional
    public void updateDeliveryInfo(String email, DeliveryInfoDto deliveryInfoDto) {
        Customer customer = customerRepository.getByEmail(email);
        customer.setFullName(deliveryInfoDto.getFullName());
        customer.setPhoneNumber(deliveryInfoDto.getPhone());
        customer.setCommuneWard(
                addressService.getCommuneWardByCode(deliveryInfoDto.getCommuneWardCode()));
        customer.setSpecificAddress(deliveryInfoDto.getSpecificAddress());
        customerRepository.save(customer);
    }

    @Transactional
    public List<ShoppingCartItem> getCart(String customerEmail) {
        return shoppingCartItemRepository.findByCustomerOrderByIdAsc(
                customerRepository.getByEmail(customerEmail));
    }
    @Transactional
    public void removeItem(String email, Long productId) {
        try{
            shoppingCartItemRepository.deleteByCustomerEmailAndProductId(email, productId);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void updateCartQuantity(String email, Long productId, double quantity) {
        Customer customer = customerRepository.getByEmail(email);
        if (customer == null) {
            throw new RuntimeException("Customer not found with email: " + email);
        }

        ShoppingCartItemId id = new ShoppingCartItemId();
        id.setCustomerId(customer.getId());
        id.setProductId(productId);

        ShoppingCartItem item = shoppingCartItemRepository.findShoppingCartItemById(id);
        if (item == null) {
            throw new RuntimeException("Shopping cart item not found for customer: "
                    + customer.getId() + ", product: " + productId);
        }

        item.setQuantity(quantity);
        shoppingCartItemRepository.save(item);
    }

    @Transactional
    public Page<Order> getOrdersByCustomerEmail(String email, int page, int size) {
        Customer customer = customerRepository.getByEmail(email);
        Pageable pageable = PageRequest.of(page,size, Sort.by("orderAt").descending());
        return orderRepository.findByCustomer(customer,pageable);
    }

    public Page<Order> searchOrderHistory(String email,
                                          String orderStatus,
                                          LocalDate fromDate,
                                          LocalDate toDate,
                                          int page, int size) {

        Customer customer = customerRepository.getByEmail(email);
        Pageable pageable = PageRequest.of(page, size, Sort.by("orderAt").descending());

        boolean hasStatus = orderStatus != null && !orderStatus.isBlank();
        boolean hasFromDate = fromDate != null;
        boolean hasToDate = toDate != null;

        LocalDateTime fromDateTime = hasFromDate ? fromDate.atStartOfDay() : null;
        LocalDateTime toDateTime = hasToDate ? toDate.atTime(23, 59, 59) : null;

        if (hasStatus && hasFromDate && hasToDate) {
            return orderRepository.findByCustomerAndOrderStatus_NameAndOrderAtBetween(customer, orderStatus, fromDateTime, toDateTime, pageable);
        }
        if (hasStatus && hasFromDate) {
            return orderRepository.findByCustomerAndOrderStatus_NameAndOrderAtAfter(customer, orderStatus, fromDateTime, pageable);
        }
        if (hasStatus && hasToDate) {
            return orderRepository.findByCustomerAndOrderStatus_NameAndOrderAtBefore(customer, orderStatus, toDateTime, pageable);
        }
        if (hasFromDate && hasToDate) {
            return orderRepository.findByCustomerAndOrderAtBetween(customer, fromDateTime, toDateTime, pageable);
        }
        if (hasFromDate) {
            return orderRepository.findByCustomerAndOrderAtAfter(customer, fromDateTime, pageable);
        }
        if (hasToDate) {
            return orderRepository.findByCustomerAndOrderAtBefore(customer, toDateTime, pageable);
        }
        if (hasStatus) {
            return orderRepository.findByCustomerAndOrderStatus_Name(customer, orderStatus, pageable);
        }

        return orderRepository.findByCustomer(customer, pageable);
    }

    public void addShoppingCartItem(Principal principal, Long productId, double quantity) {
        if (principal == null) {
            throw new RuntimeException("Bạn phải đăng nhập để thêm sản phẩm vào giỏ hàng");
        }

        Customer customer = customerRepository.getByEmail(principal.getName());
        if (customer == null) {
            throw new RuntimeException("Khách hàng có email " + principal.getName() + " không tìm thấy");
        }

        Product product = productRepository.findById(productId).orElse(null);
        if (product == null) {
            throw new RuntimeException("Sản phẩm không tồn tại");
        }

        double availableQuantity = productService.getAvailableQuantity(productId);
        ProductUnit unit = product.getUnit();
        if (unit == null) {
            throw new RuntimeException("Đơn vị sản phẩm không xác định");
        } else if (!unit.isAllowDecimal() && quantity != Math.floor(quantity)) {
            throw new RuntimeException("Sản phẩm này không cho phép số lượng thập phân");
        }

        ShoppingCartItem existingItem = shoppingCartItemRepository.findByCustomer_EmailAndProduct_Id(principal.getName(), productId);

        if ((existingItem == null && quantity < 1) || (existingItem != null && existingItem.getQuantity() + quantity < 1)) {
            throw new RuntimeException("Số lượng sản phẩm phải tối thiểu bằng 1");
        } else if (unit.isAllowDecimal() && (Math.round(quantity * 10.0) / 10.0 != quantity)) {
            throw new RuntimeException("Sản phẩm này chỉ cho phép số lượng với 1 chữ số thập phân");
        }

        if (existingItem != null) {
            if (existingItem.getQuantity() + quantity > availableQuantity) {
                throw new RuntimeException("Số lượng sản phẩm có thể thêm không vượt quá " + (availableQuantity - existingItem.getQuantity()));
            }
            updateCartQuantity(principal.getName(), productId, quantity + existingItem.getQuantity());
        } else {
            if (quantity > availableQuantity) {
                throw new RuntimeException("Số lượng sản phẩm có thể thêm không vượt quá " + availableQuantity);
            }
            ShoppingCartItem newItem = new ShoppingCartItem();
            newItem.setCustomer(customer);
            newItem.setProduct(productRepository.findById(productId).orElse(null));
            newItem.setQuantity(quantity);
            shoppingCartItemRepository.save(newItem);
        }
    }

    public double getProductQuantityInCart(Principal principal, Long id) {
        if (principal == null) {
            return 0;
        }
        ShoppingCartItem existingItem = shoppingCartItemRepository.findByCustomer_EmailAndProduct_Id(principal.getName(), id);
        if (existingItem != null) {
            return existingItem.getQuantity();
        }
        return 0;
    }

    public ShoppingCartItem getShoppingCartItemByCustomerEmailAndProductId(Principal principal, Long id) {
        if (principal == null) {
            throw new RuntimeException("Bạn phải đăng nhập để thực hiện hành động này");
        }
        ShoppingCartItem existingItem = shoppingCartItemRepository.findByCustomer_EmailAndProduct_Id(principal.getName(), id);
        if (existingItem == null) {
            throw new RuntimeException("Không tìm thấy sản phẩm trong giỏ hàng");
        }
        return existingItem;
    }

}
